import android.util.Log;
import android.text.format.DateFormat;
//import android.content.Context;

{{TEMPLATE_HEADER}}

/******************************************************************************/
/*                            BINDING ACCUMULATOR                             */
/*                                                                            */
/* Allows onEvent bindings for the same element to accumulate over multiple   */
/* onEvent calls instead of having later calls override earlier ones.         */
/******************************************************************************/
Map events = new HashMap();
String SEP = Character.toString ((char) 0); // Beanshell is stupid and wont let me write "\0"

/* Returns the set of statements bound to an element at `ref` and occuring on
 * `event`.
 */
getStatements(String ref, String event) {
  String    key = ref + SEP + event;
  ArrayList val = (ArrayList) events.get(key);
  if (val == null) {
    val = new ArrayList();
    events.put(key, val);
  }
  return val;
}

addOnEvent(String ref, String event, String statement) {
  // Calling `remove()` first ensures statement occurs once in the list, at the end.
  while(getStatements(ref, event).remove(statement));
  getStatements(ref, event).add(statement);
}

delOnEvent(String ref, String event, String statement) {
  while(getStatements(ref, event).remove(statement));
}

bindOnEvent(String ref, String event) {
  ArrayList stmts = getStatements(ref, event);
  String stmtsExpr = "";
  for (String s : stmts) {
    stmtsExpr += s;
    stmtsExpr += "; ";
  }

  onEvent(ref, event, stmtsExpr);
}

bindOnEvents() {
  for (String key : events.keySet()) {
    refevent = key.split(SEP);
    ref   = refevent[0];
    event = refevent[1];
    bindOnEvent(ref, event);
  }
}

/******************************************************************************/
/*                            INIT VARIABLES                                  */
/*                                                                            */
/******************************************************************************/

showWarning("Heurist-generated module", "This module has been generated based on the structure of a Heurist (http://HeuristNetwork.org) database. You can use the module as-is, customise it yourself, or we can help you. Contact info@fedarch.org or info@HeuristNetwork.org for help.");

Map rectypeToUuid = new HashMap(); //list of edit form in use
getUuid(String rectypeTab) {
	String uid = rectypeToUuid.get(rectypeTab);
	if("".equals(uid)){
        uid = null;
    }
	return uid;
}
setUuid(String rectypeTab, String uuid) {
  rectypeToUuid.put(rectypeTab, uuid);
}

//stack of tabs in use to prevent edit twice
ArrayList tabs_edit = new ArrayList();

// stack of calls to select (see last_invoker)
// populated on selectEntity tab show
// removed on onShowEditForm
// cleared in clearStacks (conttol/data or control/map show)

// list of pairs:  rectype to search = field to fill with selected value
ArrayList tabs_select = new ArrayList();

//keeps rectype to select(browse) and field path to assign the result of selection
// for example Person=DigitalMediaItem/DigitalMediaItem_General_Information/Creators
String last_invoker = null;

List attachedGeometry = null;  //geometry object from map to be attached to current entity

ArrayList rectypeToEntity = new ArrayList();
ArrayList rectypeToEntityGeo = new ArrayList(); //geo-enabled entities 
ArrayList rectypeToEntityMain = new ArrayList(); //main entry entities 

/*** START: this section of code depends on the module and entity types selected ***/
{{TEMPLATE_EVENTS}}

//
// assign default values for new Record
//
onInitNewRecord( String rectypeTab ){
{{TEMPLATE_DEFAULTVALUES}}
}
/*** END: this section of code depends on the module and entity types selected ***/

//
// pickup date from popup dialog
//
pickupDate(fieldid){
	showDateAlert("Define", "Set Date:", "assignDate(\""+fieldid+"\", getLastDateAlertInput())", "showToast(\"Dialog canceled\")");
}

//String shortDateFormat  = Settings.System.getString(getActivity().getContentResolver(), Settings.System.DATE_FORMAT);
//android.text.format.DateFormat dateFormat = new android.text.format.DateFormat();
//android.text.format.DateFormat dateFormat = android.text.format.DateFormat.getDateFormat(getApplicationContext());

//
assignDate(fieldid, value){
	setFieldValue(fieldid, value);
/*
	try{
		//String pattern = android.text.format.DateFormat.getDateFormat();
		String pattern = Settings.System.getString(getActivity().getContentResolver(), Settings.System.DATE_FORMAT);
print ("date "+value+"  "+pattern);
		Date dtvalue = (new java.text.SimpleDateFormat(pattern)).parse(value);
print (dtvalue);
		setFieldValue(fieldid, dateFormat.format("yyyy-MM-dd hh:mm:ss", dtvalue));
	}catch(Exception e){
print ("Exception "+e.getMessage());
	}
*/
}

//
//
//
setTimestamp(String path) {
    time = getCurrentTime();
    setFieldValue(path, time);
    //new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss z").format(new Date()));
}

//
// return entity name by tab name
//
getEntityNameByTabname(rectypeTab) {

	for (NameValuePair pair : rectypeToEntity) {
		if(pair.getName().equals(rectypeTab)){
			return pair.getValue();
		}
	}
    return null;
}

//
// get tab name by entity name
//
getTabnameByEntityName(entName) {

	for (NameValuePair pair : rectypeToEntity) {
		if(pair.getValue().equals(entName)){
			return pair.getName();
		}
	}
    return null;
}

//
// load all selectors for terms for every rectype
//
loadAllAttributes(){
{{TEMPLATE_SELECTORS}}
}

/*** END: this section of code depends on the module and entity types selected ***/

/******************************************************************************/
/*                            SELECT ENTITY                                    */
/*                                                                            */
/******************************************************************************/

addOnEvent("selectEntity/data", "show", "onShowSelect()");
addOnEvent("selectEntity/data/entityList", "click", "onSelectEntity()");
addOnEvent("selectEntity/data/newEntity", "click", "onAddNewEntityWhenSelect()");

//
// onshow list of entities (to fill pointer field)
//
onShowSelect(){

    if(tabs_select.size()>0 && !isNull(last_invoker) && last_invoker.equals(tabs_select.get(tabs_select.size()-1))){
        //initial call - open new select

    }else{
        //back call - return after new entity addition
        if(tabs_edit.size()>0){
            tabs_edit.remove(tabs_edit.size()-1);
        }
    }
    last_invoker = null;

    //detect what entity type show in select list
    String last_select_callback = tabs_select.get(tabs_select.size()-1);

    String[] parts = last_select_callback.split("=");
    String rectypeTab = parts[0]; //rectype to search
    String fieldpath = parts[1]; //

    //search entity for given entType
    String entName = getEntityNameByTabname( rectypeTab );
    fetchEntityList(entName, new FetchCallback() {
        onFetch(result) {
            populateList("selectEntity/data/entityList", result);
        }
    });

}
//
// onshow edit form for particular entity
//
onShowEditForm(rectypeTab){

    if(tabs_edit.size()>0 && rectypeTab.equals(tabs_edit.get(tabs_edit.size()-1))){
        //return from select
        if(tabs_select.size()>0){
            tabs_select.remove(tabs_select.size()-1);
        }
    }else{
        tabs_edit.add(rectypeTab);
    }

	  //fill id
	  String entid = getUuid(rectypeTab);

	  if(isNullOrEmpty(entid)){
		onInitNewRecord( rectypeTab );
	  }
}
/*** selectEntity functions ***/
//
// search for resource for pointer filed - open select tab
// rectype - to search
// fieldpath - field to assign
//
startSelectEntity(rectypeTab, fieldpath) {

    last_invoker = rectypeTab+"="+fieldpath;

    tabs_select.add(rectypeTab+"="+fieldpath); //keep last call
    showTabGroup("selectEntity");

}
//
// create new record from select (in case required resource not found)
//
onAddNewEntityWhenSelect(){
    String last_select_callback = tabs_select.get(tabs_select.size()-1);
    String[] parts = last_select_callback.split("=");
    String rectypeTab = parts[0];

    for (String rt : tabs_edit) {
        if (rt.equals(rectypeTab) ) {
            //prevents show edit form in case it is already in use
            showWarning("Already in use", "Cannot create new "+rectypeTab+". Save previous");
            return;
        }
    }

	setUuid(rectypeTab, "");
    newTabGroup(rectypeTab); //load and clear fields
}

//
// user click on record in list - back to edit form and fill pointer field
//
onSelectEntity() {

    String child_uuid = getListItemValue(); //get id from list
    String last_select_callback = tabs_select.get(tabs_select.size()-1);

    String[] parts = last_select_callback.split("=");
    String fieldname = parts[1]; //
    parts = fieldname.split("/");
    String rectypeTab = parts[0]; //editing rectype
    String rectype_tab = parts[1];
    String field = parts[2];

    //back to edit form
    cancelTabGroup("selectEntity", false);
    showTab(rectypeTab+"/"+rectype_tab);

    //showToast("selected "+child_uuid);

    //ArrayList pairs = new ArrayList();
    //pairs.add(new NameValuePair("selected "+child_uuid, child_uuid));

    //fill pointer field
    populateDropdownByQuery(fieldname, child_uuid);

    //delete previous relation
    deleteRelation(fieldname);

    String fieldname_uid = getPointerUidFieldName(fieldname);
    setFieldValue(fieldname_uid, child_uuid);
}
//
// Returns path to UID field on hidden tab for given resource attribute (field)
// for example we have  fieldname Grandparent/Grandparent_General_Information/DedaToPapa  (selector)
// it means that uid field will be Grandparent/Grandparent_General_uids/DedaToPapa_UID    (hidden field that contain relation ID)
//
getPointerUidFieldName(String fieldname){
    String[] parts = fieldname.split("/");
    parts[1] = parts[0]+"_uids"; //hidden tab with uid fields
    parts[2] = parts[2]+"_UID";  //pointer field to keep UID of resource record
    return parts[0]+"/"+parts[1]+"/"+parts[2];
}

//
// get current record id by name of any field
//
getUuidByField(String fieldname){
    String[] parts = fieldname.split("/");
    String rectypeTab = parts[0];
    return getUuid(rectypeTab);
}

//
// Clear resource attribute (field) - dropdown and UID field on hidden tab
//
clearPointerUI(String fieldname){
    ArrayList pairs = new ArrayList();
    pairs.add(new NameValuePair("select with Browse button(s)", ""));
    populateDropDown(fieldname, pairs );

    String fieldname_uid = getPointerUidFieldName(fieldname);
    setFieldValue(fieldname_uid, "");
}

//
// Remove relationship from database
//
clearPointer(String fieldname){
    deleteRelation(fieldname);
    clearPointerUI(fieldname);
}

//
// Check empty or null string
//
isNullOrEmpty(String val){
    return null==val || "".equals(val) || "null".equals(val);
}

//
// Fill dropdown (name) for pointer field by value of hidden UID field
//
fillPointer(String fieldname, String child_uuid){  //NEW
    if(isNullOrEmpty(child_uuid)){
        clearPointerUI(fieldname);
    }else{
        populateDropdownByQuery(fieldname, child_uuid);
    }
}

/*** record management function ***/

//
// Create new record for main entity
// (some entities are not accessible from main tab - they can be added from select tab only)
//
newEntity(String rectypeTab){

    if (isNull(rectypeTab)){
        entName = getFieldValue("control/data/entityTypeList");
        rectypeTab = getTabnameByEntityName(entName);
		if(isNull(rectypeTab)){
            showWarning("Cannot edit", "Entity type '"+entName+"' cannot be edited");
            return;
		}
    }

    for (String rt : tabs_edit) {
        if (rt.equals(rectypeTab) ) {
            showWarning("Already in use", "Cannot create new '"+rectypeTab+"'. Save previous");
            return;
        }
    }

	setUuid(rectypeTab, "");
    newTabGroup(rectypeTab); //load and clear fields
}
//
// Show edit form by record id and record type
//
loadEntityById(String entid, String entName) {

    // EntID check
    if (isNullOrEmpty(entid)) return;
    //showToast(entid);

    // Show rectype tabgroup
    rectypeTab = getTabnameByEntityName(entName);
	setUuid(rectypeTab, entid);

    showTabGroup(rectypeTab, entid, new FetchCallback() {
        onFetch(result) {

            entity = result;

            fetchedAttributes = entity.getAttributes();

            for (attribute : fetchedAttributes) {
                String attrName = attribute.getName();
                String attrVal = attribute.getMeasure();
                {{TEMPLATE_RELATED_INIT}}
            }
        }
        onError(message) {
            showToast(message);
        }
    });
}


//
// save relations (on save new record)
//
saveRelations(String rectypeTab){
        String uuid = getUuid(rectypeTab);
        if(!isNullOrEmpty(uuid)){
            {{TEMPLATE_RELATED_SAVE}}
        }
}

//
// Save relation
//
saveRelation(String relationName, String parent_uuid, String fieldname){
    String fieldname_uid = getPointerUidFieldName(fieldname);
    String child_uuid = getFieldValue(fieldname_uid);
    if(!isNullOrEmpty(child_uuid)){
        String relationshipidQuery = "select relationshipid from parentchild where parentuuid = '"+parent_uuid+"' and childuuid = '"+child_uuid+"';";
        fetchOne(relationshipidQuery, new FetchCallback() {
          onFetch(result) {
            if(isNull(result) || result.size()==0 || isNullOrEmpty(result.get(0))){ //to avoid duplications
                saveEntitiesToRel(relationName, parent_uuid, child_uuid);
            }
          }
          onError(message) {
            showToast(message);
          }
        });
    }
}

//
// Delete relation for given link field
//
deleteRelation(fieldname){

    String parent_uuid = getUuidByField(fieldname);
    String child_uuid = getFieldValue( getPointerUidFieldName(fieldname) );

    if (!(isNullOrEmpty(parent_uuid) || isNullOrEmpty(child_uuid))){

        String relationshipidQuery = "select relationshipid from parentchild where parentuuid = '"+parent_uuid+"' and childuuid = '"+child_uuid+"';";
        fetchOne(relationshipidQuery, new FetchCallback() {
          onFetch(result) {
            if(!isNull(result) && result.size()>0){
                reln_id = result.get(0);
                if(!isNullOrEmpty(reln_id)){
                    String deletequery = "insert into aentreln (uuid, relationshipid, deleted, participatesverb, userid) SELECT uuid, relationshipid, 'true', participatesverb, '"+userid+"' FROM latestnondeletedaentreln WHERE relationshipid = '"+reln_id+"';";
                    fetchOne(deletequery, null);
                    //deleteRel(reln_id);
                }
            }
          }
          onError(message) {
            showToast(message);
          }
        });
    }
}

//
//
//
onLoadEntity(String entid, String entName){
}

// Returns the query to load information about a certain entity
getEntityQuery(uid) {
            
    return "SELECT uuid, response "+
                       "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
                       " WHERE uuid = '"+uid+"'";
}

getEntityQuery_OLD(uid) {
    return  "SELECT uuid, group_concat(coalesce(measure   || ' '  || vocabname || '('  ||  freetext ||'; '|| (certainty * 100.0) || '% certain)',  "+
            "                                     measure   || ' (' || freetext  || '; ' || (certainty * 100.0) || '% certain)',  "+
            "                                     vocabname || ' (' || freetext  || '; ' || (certainty * 100.0) || '% certain)',  "+
            "                                     measure   || ' '  || vocabname || ' (' || (certainty * 100.0) || '% certain)',  "+
            "                                       vocabname || ' (' || freetext  || ')',  "+
            "                                       measure   || ' (' || freetext  || ')',  "+
            "                                     measure   || ' (' ||(certainty * 100.0) || '% certain)',  "+
            "                                     vocabname || ' (' ||(certainty * 100.0) || '% certain)',  "+
            "                                     freetext  || ' (' ||(certainty * 100.0) || '% certain)',  "+
            "                                     measure,  "+
            "                                     vocabname,  "+
            "                                     freetext), ' ') as response  "+

            "FROM (select * from latestNonDeletedArchentIdentifiers order by attributename) "+
            "WHERE uuid = '"+uid+"' "+
            "GROUP BY uuid;";
}

// Executes a query for the given uid and then uses the result to populate a dropdown
// populate pointer dropdown
//
populateDropdownByQuery(String fieldname, String uid) {
    fetchAll(getEntityQuery(uid), new FetchCallback() {
        onFetch(result) {
            if(isNull(result) || result.size()==0){
                //nothing found - apparently linked record has been removed
print ("Child was deleted - remove relation");
                clearPointer(fieldname);
            }else{
                populateDropDown(fieldname, result);
            }
        }
    });
}

//
// insert/update entity
//
saveEntity(String rectypeTab, Boolean needValidation, Boolean andclose) {

    if(needValidation && !validateEntity( rectypeTab, true )){
            showToast("Entered data are not valid");
			return;
    }

    String uuid = getUuid(rectypeTab);
    
    // save record/entity
    saveTabGroup(rectypeTab, uuid, attachedGeometry, null, new SaveCallback() {
        onSave(uuid, newRecord) {

            setUuid(rectypeTab, uuid);
            saveRelations(rectypeTab);
			showToast("Successfully saved data!");

			if(null!=attachedGeometry){
				mapRefresh(); //refresh map
			}

			String entName = getEntityNameByTabname( rectypeTab );
			searchEntity(entName); //refresh list

/* debug
			fetchArchEnt(uuid, new FetchCallback() {
				onFetch(entity) {
					geometry = entity.getGeometryList();
print("after save "+geometry);
				}
			});
*/
        }
        onError(message) {
            showToast(message);
        }
        
        
        }, true ); //false for disable auto save

    if(andclose){
			goBack();
    }

}

//
//
//
saveAttachedGeometry(String rectypeTab, String gps_accuracy){

    String uuid = getUuid(rectypeTab);

	if(isNull(uuid)){

		showToast("Please enter data first and let a save occur.");

	}else if(!isNull(attachedGeometry)){


		if(isNull(gps_accuracy)){
			gps_accuracy = "Geometry is manually plotted";
		}

		//save annotation
		List attributes = createAttributeList();
		attributes.add(createEntityAttribute("Latitude", gps_accuracy, null, null, null));

		String entName = getEntityNameByTabname(rectypeTab);

		saveArchEnt(uuid, entName, attachedGeometry, attributes, new SaveCallback() {
				onSave(uuid, newRecord) {
					showToast("Successfully saved geometry!");
					mapRefresh();
				}
		});
	}
}

//
// Deleting entities
//
deleteEntity(rectypeTab){
    String uuid = getUuid(rectypeTab);
    if (!isNull(uuid)) {
        showAlert("Confirm Deletion", "Press OK to Delete this entity!", "deleteEntityConfirmed(\""+rectypeTab+"\")", "deleteRecordCanceled()");
    }else{
		showToast("Entity is not saved");
	}
}
deleteEntityConfirmed(rectypeTab){
    String uuid = getUuid(rectypeTab);

    deleteArchEnt(uuid, new DeleteCallback() {
        onDelete(uuid) {
            cancelTabGroup(rectypeTab, false);

			String entName = getEntityNameByTabname( rectypeTab );
			searchEntity(entName);
			mapRefresh();
        }
    });
}
deleteEntityCanceled(){
    showToast("Delete Cancelled.");
}
/*** END record management function ***/

//
// clear edit/select stacks on control/data, control/map show
//
clearStacks(){
   tabs_select.clear();
   tabs_edit.clear();
   last_invoker = null;
}

/******************************************************************************/
/*                             NAVIGATION DRAWER                              */
/******************************************************************************/
addOnEvent("User", "show", "removeNavigationButtons()");
addOnEvent("control", "show", "removeNavigationButtons()");

removeNavigationButtons() {
  removeNavigationButton("new");
  removeNavigationButton("duplicate");
  removeNavigationButton("delete");
  removeNavigationButton("validate");
}

addNavigationButtons(String rectypeTab) {
  removeNavigationButtons();

  //only some rectype should be validated. SPECIFIC
  List tabgroupsToValidate = new ArrayList();
  {{TEMPLATE_TOVALIDATE}}

  addNavigationButton("new", new ActionButtonCallback() {
    actionOnLabel() {
      "{New}";
    }
    actionOn() {
      if(!isNull(getUuid(rectypeTab))) {
		  //clearStacks();
          newEntity(rectypeTab);
          showToast("{New_record_created}");
		  onShowEditForm(rectypeTab);
      } else {
          showAlert("{Warning}", "{Any_unsaved_changes_will_be_lost}", "newEntity(\""+rectypeTab+"\")", "");
      }
    }
  }, "success");
  addNavigationButton("duplicate", new ActionButtonCallback() {
    actionOnLabel() {
      "{Duplicate}";
    }
    actionOn() {
      if(!isNull(getUuid(rectypeTab))) {
          duplicateEntity(rectypeTab);
      } else {
          showWarning("{Warning}", "{This_record_is_unsaved_and_cannot_be_duplicated}");
      }
    }
  }, "primary");
  addNavigationButton("delete", new ActionButtonCallback() {
    actionOnLabel() {
      "{Delete}";
    }
    actionOn() {
      deleteEntity(rectypeTab);
    }
  }, "danger");
  if (tabgroupsToValidate.contains(rectypeTab)) {
    addNavigationButton("validate", new ActionButtonCallback() {
      actionOnLabel() {
        "{Validate}";
      }
      actionOn() {
		validateEntity( rectypeTab, false );
        //String validationFunction = "validate" + rectypeTab.replaceAll("_", "") + "()";
        //eval(validationFunction);
      }
    }, "default");
  }
}

/******************************************************************************/
/*                                   DUPLICATION                              */
/******************************************************************************/

// Duplicates the current record of the given tabgroup
duplicateEntity(String tabgroup) {
  dialog = showBusy("Duplicating", "Please wait...");

  //String duplicateTabGroupFunction = "duplicate" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "duplicateTabgroup()"
  //eval(duplicateTabGroupFunction);
  //Log.d("duplicateRecord", tabgroup);

  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);

      Boolean enable_autosave = true;

/* it does not work
      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());
		  makeDuplicateRelationships(result, getUuid(tabgroup));
          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });
*/
      showToast("{Duplicated_record}");
      dialog.dismiss();
/*
      saveTabGroup(tabgroup, getUuid(tabgroup), null, null, new SaveCallback(){
        onSave(autosaveUuid, autosaveNewRecord) {
            setUuid(tabgroup, autosaveUuid);
			String entName = getEntityNameByTabname( rectypeTab );
			searchEntity(entName); //refresh list
        }
      }, enable_autosave);
*/
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();
      //excludeAttributes.add("General Photo");

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });

}

// generic fetch saved attributes query
getDuplicateAttributeQuery(String originalRecordID, String attributesToDupe) {
  if (attributesToDupe.equals("")) {
    attributesToDupe = "''";
  }
  String duplicateQuery = "SELECT attributename, freetext, vocabid, measure, certainty " +
                          "  FROM latestnondeletedaentvalue JOIN attributekey USING (attributeid) " +
                          " WHERE attributename IN ('', "+attributesToDupe+") " +
                          "   AND uuid = '"+originalRecordID+"'; ";
  return duplicateQuery;
}

getDuplicateRelnQuery(String originalRecordID) {
  String dupeRelnQuery = "SELECT relntypename, parentparticipatesverb, childparticipatesverb, parentuuid "+
                         "  FROM parentchild join relationship using (relationshipid) "+
                         "  JOIN relntype using (relntypeid) "+
                         " WHERE childuuid = '"+originalRecordID+"' " +
                         "   AND parentparticipatesverb = 'Parent Of' ";
  return dupeRelnQuery;
}

makeDuplicateRelationships(fetchedAttributes, String newuuid){
  Log.e("Module", "makeDuplicateRelationships");
  for (savedAttribute : fetchedAttributes){
    //  saveEntitiesToHierRel(relnname, parent, child, parentverb, childverb, relSaveCallback);
    //relntypename, parentparticipatesverb, childparticipatesverb, childuuid
    Log.e("Module", "in");
    String relntypename           = savedAttribute.get(0);
    String parentparticipatesverb = savedAttribute.get(1);
    String childparticipatesverb  = savedAttribute.get(2);
    String childuuid              = savedAttribute.get(3);
    saveEntitiesToHierRel(relntypename, newuuid, childuuid, parentparticipatesverb, childparticipatesverb, null);
  }
}

// generic get extra attributes
getExtraAttributes(fetchedAttributes) {
  List extraAttributes = createAttributeList();
  Log.d("Module", "Duplicating fetched attributes: " + fetchedAttributes.toString());
  for (savedAttribute : fetchedAttributes) {
    extraAttributes.add(
      createEntityAttribute(
        savedAttribute.get(0),
        savedAttribute.get(1),
        savedAttribute.get(2),
        savedAttribute.get(3),
        savedAttribute.get(4)
      )
    );
  }
  return extraAttributes;
}

/******************************************************************************/
/*        ENTITY AND RELATIONSHIP SAVING AND LOADING HELPER FUNCTIONS         */
/******************************************************************************/

/** Saves two entity ids as a relation. **/
saveEntitiesToRel(String type, String entity1, String entity2) {
  String callback = null;
  saveEntitiesToRel(type, entity1, entity2, callback);
}

/** Saves two entity ids as a relation with some callback executed. **/
saveEntitiesToRel(String type, String entity1, String entity2, String callback) {
  String e1verb = null;
  String e2verb = null;
  saveEntitiesToHierRel(type, entity1, entity2, e1verb, e2verb, callback);
}

/** Saves two entity ids as a hierachical relation with some callback executed. **/
saveEntitiesToHierRel(String type, String entity1, String entity2, String e1verb, String e2verb, String callback) {
  if (isNull(entity1) || isNull(entity2)) return;
  saveRel(null, type, null, null, new SaveCallback() {
    onSave(rel_id, newRecord) {
      addReln(entity1, rel_id, e1verb);
      addReln(entity2, rel_id, e2verb);
      if(!isNull(callback)) {
         execute(callback);
      }
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  });
}

/******************************************************************************/
/*                                   VALIDATION                               */
/******************************************************************************/
/* `ref`  is a reference/path to a field
 * `name` is a human-readable name for that field
 * `cond` is a String containing a boolean expression that evaluates to true if
 *        and only if the the field pair returned by this function should be
 *        validated.
 *
 *  Returns a field pair (really just an ArrayList).
 */
fieldPair(String ref, String name, Boolean isMandatory, String cond) {
  List fp = new ArrayList();
  fp.add(ref);
  fp.add(name);
  fp.add(isMandatory);
  fp.add(cond);
  return fp;
}
/* Returns true if field specified by `ref` is valid. False otherwise.
 */
isValidField(String ref) {
  return !isNull(getFieldValue(ref));
}
/* `format` can either be HTML or PLAINTEXT
 */
validateFields(List fields, String format) {
  Integer numInvalid = 0;

  /* Build validation message string (and count how many invalid fields exist) */
  String out = "Please fill out the following fields:\n";
  for(f : fields) {
    String ref  = f.get(0); // Reference to field
    String name = f.get(1); // Human-readable name
    Boolean isMandatory = f.get(2);
    String cond = f.get(3); // Validation condition

    // Add any invalid fields to the output and tally them
    if (!isValidField(ref)) {
      out += "- " + name + " is invalid\n";
      numInvalid++;
    }
/*
    // Only validate a field whose validation condition evaluates to `true`
	if(!isNull(cond)){
		String condition = cond+"(\""+ref+"\")";
print ("validate: "+condition);
		Boolean isValid = (Boolean) eval( condition );
		if(!isValid){
			out += "- " + name + " has wrong format\n";
			numInvalid++;
		}
	}
*/

    // Add any invalid fields to the output and tally them
    if (isMandatory &&  "".equals(getFieldValue(ref))) {
      out += "- " + name + " is mandatory\n";
      numInvalid++;
    }
  }
  // All the fields are valid; just overwrite `out` with a cheery message
  if (numInvalid == 0)
    out = "";

  /* Format the output as dictated by `format` */
  if (format == "HTML") {
    out = out.replace("\n", "<br>");
  } else if (format == "PLAINTEXT") {
    ;
  }

  return out;
}

//
validateDate(fieldid){
	String value = getFieldValue(fieldid);
	if(!"".equals(value)){
		try{
			Date dtvalue = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss z").parse(value);
			return (null!=dtvalue);
		}catch(Exception e){
			return false;
		}
	}else{
		return true;
	}
}

//
//
//
validateEntity( rectypeTab, isVoid ){

  List f = new ArrayList(); // Fields to be validated

{{TEMPLATE_FIELDS_TOVALIDATE}}

  String validationMessage = validateFields(f, "PLAINTEXT");
  Boolean isValid = "".equals(validationMessage);
  
	if(isValid){
        if(!isVoid){
		    showWarning("Validation Results", "All fields contain valid data!");
        }
	}else{
		showWarning("Validation Results", validationMessage);
	}
  
  return isValid;
}

/******************************************************************************/
/*                                   SEARCH/MAIN LIST                         */
/******************************************************************************/
addOnEvent("control/data"                    , "show" , "loadEntityTypeList()");
addOnEvent("control/data/entityTypeList"     , "click", "onEntityTypeSelect()"); //load list of entities for particular entity type
addOnEvent("control/data/entitySearchButton" , "click", "searchEntity( null )");
addOnEvent("control/data/entityAllButton"    , "click", "onEntityTypeSelect()");
addOnEvent("control/data/entitySearchTerm"   , "click", "searchClear()");
addOnEvent("control/data/newEntity"          , "click", "newEntity(null)");
addOnEvent("control/data/entityList"         , "click", "loadEntity()"); //load entity after tap in the list

searchClear(){
  setFieldValue("control/data/entitySearchTerm","");
}

//
// reload list of records on control/data on rectype selection
// forEntityType if null it forces the reload
//
searchEntity( forEntityType ){

  // get current entity type
  String entName = getFieldValue("control/data/entityTypeList");

  if(isNull(forEntityType) || forEntityType.equals(entName)){

	String term    = getFieldValue("control/data/entitySearchTerm");
    if(isNullOrEmpty(term)){ //load all

		fetchEntityList(entName, new FetchCallback() {
			onFetch(result) {
				populateList("control/data/entityList", result);
			}
		});

    }else{

		String searchQuery = "SELECT uuid, response "+
					   "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
                       " WHERE uuid in (SELECT uuid "+
                       "                  FROM latestNonDeletedArchEntIdentifiers "+
                       "                 WHERE measure LIKE '"+term+"'||'%'  "+
                       "                   AND ( aenttypename LIKE '"+entName+"' ) "+
                       "                )  "+
                       " ORDER BY response "+
                       " LIMIT ? "+
                       "OFFSET ? ";

		populateCursorList("control/data/entityList", searchQuery, 25);
	}
  }
}

//
// event listener on show of control/data (list of entities and records)
// loads all available entity types into a dropdown
//
loadEntityTypeList() {

   String entName = getFieldValue("control/data/entityTypeList");

   // Populate entity type dropdown - only once
   if(isNullOrEmpty(entName)){

		populateDropDown("control/data/entityTypeList", rectypeToEntityMain);
		searchEntity( null );
/*
		fetchAll("select aenttypename, aenttypename from aenttype;", new FetchCallback() {
			onFetch(result) {
				populateDropDown("control/data/entityTypeList", result);
				searchEntity( null );
			}
		});
*/
   }

   clearStacks();
}

//
// On select entity type in list - reload list of entities
//
onEntityTypeSelect(){
	searchClear();
	searchEntity(null);
}

//
// On select entity in list - load edit form
//
loadEntity() {
    String uid = getListItemValue(); //get id from list
    String entName = getFieldValue("control/data/entityTypeList");
    loadEntityById(uid, entName);
}

/*** INIT ATTRIBUTES ***/
loadAllAttributes();

/*** MAP ***/

DATA_ENTRY_LAYER = "Data Entry Layer";
DATA_ENTRY_LAYER_ID = 0;

//
// remove and recreate canvas layer
//
onClearMap() {
   removeLayer("control/map/map", DATA_ENTRY_LAYER_ID);
   DATA_ENTRY_LAYER_ID = createCanvasLayer("control/map/map", DATA_ENTRY_LAYER);
   setSelectedLayer("control/map/map", DATA_ENTRY_LAYER);
   attachedGeometry = null;
}

//
// create new entity from map tab
//
onCreateEntityFromMap() {

	if(doAttachGeometry( null )){
        String entName = getFieldValue("control/map/entityTypeList");
		String rectypeTab = getTabnameByEntityName(entName);
        newEntity(rectypeTab);
	}
}

//
//
//
doAttachGeometry(String rectypeTab){
    List geomList = getGeometryList("control/map/map", DATA_ENTRY_LAYER_ID);
    if (geomList == null || geomList.size() == 0) {
		attachedGeometry = null;
        showWarning("Warning", "No geometry found on data entry layer. Select 'Date Entry' layer on map and plot an object");
		return false;

    } else {
        attachedGeometry = geomList;
		if(!isNull(rectypeTab)){ //if it is called from form - try to save geometry at once
			saveAttachedGeometry(rectypeTab, null);
		}
		return true;
    }
}

//
//
//
zoomGPS(){
    Object position = getGPSPositionProjected();
    Object projPosition = getGPSPositionProjected();
    if (projPosition != null ){
        Double latitude = projPosition.getLatitude();
        Double longitude = projPosition.getLongitude();
        showToast("Zooming to "+position.getLongitude()+", "+position.getLatitude());
        setMapFocusPoint("control/map/map", longitude, latitude);
    } else {
        showToast("{GPS_Not_Initialised}");
    }

}


//
// @todo - show map tab and zoom to current record
//
mapRecord(rectypeTab){

    String uid = getUuid(rectypeTab);
    if (!isNull(uid)) {
        // Fetch entity
        fetchArchEnt(uid, new FetchCallback() {
            onFetch(entity) {
                data = entity.getGeometryList();
                //setMapFocusPoint("control/map/map", longitude, latitude);
            }
        });

    }
}

//
// list of color by rectypeTab
//
Map rectypeToColor = new HashMap();
Map rectypeToMapLayer = new HashMap();

//
// load database layer for particular type
//
mapLoadLayer(rectypeTab) {

	layerID = rectypeToMapLayer.get(rectypeTab);
//print("recreate layer for "+rectypeTab+"   "+layerID);

	if(null!=layerID){
		//removeLayer("control/map/map", layerID);
		refreshMap("control/map/map");
		return;
	}

	Boolean isEntity = true;
    String queryName = rectypeTab;
	String entName = getEntityNameByTabname( rectypeTab );
    String querySql = "SELECT uuid, aenttimestamp FROM latestNonDeletedArchEnt join aenttype using (aenttypeid) where aenttypename = '"+entName+"'";

	clr = rectypeToColor.get(rectypeTab);
	if(null==clr){
		clr = Color.RED;
	}

    ps = createPointStyle(10, clr, 0.2f, 0.5f);
    ls = createLineStyle(10, clr, 0.05f, 0.3f, null);
    pos = createPolygonStyle(10, Color.parseColor("#440000FF"), createLineStyle(10, clr, 0.01f, 0.3f, null));
    ts = createTextStyle(10, clr, 40, Typeface.SANS_SERIF);

    layerID = showDatabaseLayer("control/map/map", rectypeTab, isEntity, queryName, querySql, ps, ls, pos, ts);
	rectypeToMapLayer.put(rectypeTab, layerID);
}

//
//
//
mapInit() {
    setMapZoom("control/map/map", 19.0f);

	for (String key : rectypeToColor.keySet()) {
		mapLoadLayer(key);
	}

    DATA_ENTRY_LAYER_ID = createCanvasLayer("control/map/map", DATA_ENTRY_LAYER);
    setSelectedLayer("control/map/map", DATA_ENTRY_LAYER);

	populateDropDown("control/map/entityTypeList", rectypeToEntityGeo);

	addOnEvent("control/map", "show", "clearStacks()");
	addOnEvent("control/map/clear", "click", "onClearMap()");
	addOnEvent("control/map/create", "click", "onCreateEntityFromMap()");
	addOnEvent("control/map/zoomGPS", "click", "zoomGPS()");
}

{{TEMPLATE_MAPCOLORS}}

/* included into previous template
mapRefresh(){
	refreshMap("control/map/map");
	onClearMap();
}
mapInit();
*/


/******************************************************************************/
/*                                 ACTION BAR (top right menu)                */
/******************************************************************************/
addActionBarItem("clean_synced_files", new ActionButtonCallback() {
  actionOnLabel() {
    "{Clean_Synced_Files}";
  }
  actionOn() {
    cleanSyncedFiles();
  }
});

addActionBarItem("sync", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Sync}";
  }
  actionOn() {
    setSyncEnabled(false);
    setFileSyncEnabled(false);
    showToast("{Sync_Disabled}");
  }
  isActionOff() {
    isSyncEnabled();
  }
  actionOffLabel() {
    "{Enable_Sync}";
  }
  actionOff() {
    setSyncEnabled(true);
    setFileSyncEnabled(true);
    showToast("{Sync_Enabled}");
  }
});

addActionBarItem("internal_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Internal_GPS}";
  }
  actionOn() {
    stopGPS();
    showToast("{Internal_GPS_Disabled}");
    updateGPSDiagnostics();
  }
  isActionOff() {
    isInternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_Internal_GPS}";
  }
  actionOff() {
    if(isExternalGPSOn()) {
      stopGPS();
    }
    startInternalGPS();
    showToast("{Internal_GPS_Enabled}");
    updateGPSDiagnostics();
  }
});

if({{HASCONTROL_GPSEXT}}){

addActionBarItem("external_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_External_GPS}";
  }
  actionOn() {
    stopGPS();
    if (isBluetoothConnected()) {
      showToast("{External_GPS_Disabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
    }
    updateGPSDiagnostics();
  }
  isActionOff() {
    isExternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_External_GPS}";
  }
  actionOff() {
    if(isInternalGPSOn()) {
      stopGPS();
    }
    startExternalGPS();
    if(isBluetoothConnected()) {
      showToast("{External_GPS_Enabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
      this.actionOn();
    }
    updateGPSDiagnostics();
  }
});

}

/******************************************************************************/
/*                                    GPS                                     */
/******************************************************************************/
addOnEvent("control/gps", "show", "updateGPSDiagnostics()");

updateGPSDiagnostics() {
  String diagnosticsRef = "control/gps/GPS_Diagnostics";

  if (diagnosticsRef.equals("")) {
    return;
  }

  String status         = "";
  String previousStatus = getFieldValue(diagnosticsRef);
  String notInitialised = "{GPS_is_not_initialised}";

  // Check if GPS is initialised or was previously initialised.
  if (!isExternalGPSOn() && !isInternalGPSOn()) {
    if (!isNull(previousStatus) && !previousStatus.equals(notInitialised)) { // previous gps status is some last valid coordinate.
      // This is hackish. Arch16n substitution happens only at display-time, but the following if clause requires substitution to have happened at run-time
      String error = "";
      error = "{GPS_is_no_longer_initialised}. {Previous_status}:";
      setFieldValue(diagnosticsRef, error);   // Arch16n entry is substituted after this
      error = getFieldValue(diagnosticsRef);

      // check that error message wasn not previously appended to the previous status message.
      if (previousStatus.length()    >= error.length() &&
          previousStatus.subSequence(0, error.length()).equals(error)) {
        status = previousStatus;
      } else {
        status = error + "\n" + previousStatus;
      }
    } else {
      status = notInitialised;
    }
  } else {
    status += "{Internal_GPS}: ";
    if (isInternalGPSOn())
    {
      status += "{on}";
    } else {
      status += "{off}";
    }
    status += "\nExternal GPS: ";
    if (isExternalGPSOn())
    {
      if (isBluetoothConnected()) {
        status += "{on_and_bluetooth_connected}";
      } else {
        status += "{on_and_bluetooth_disconnected}";
      }
    } else {
      status += "{off}";
    }
    Object position = getGPSPosition();
    if (position != null) {
      Object projPosition = getGPSPositionProjected();
      status += "\n{Latitude}: " + position.getLatitude();
      status += "   {Longitude}: " + position.getLongitude();
      status += "\n{Northing}: " + projPosition.getLatitude();
      status += "   {Easting}: " + projPosition.getLongitude();
      status += "\n{Accuracy}: " + getGPSEstimatedAccuracy();
    } else {
      status += "\n{Position}: {no_GPS_position_could_be_found}";
    }
  }
  setFieldValue(diagnosticsRef, status);
}

/******************************************************************************/
/*                                 USER LOGIN                                 */
/******************************************************************************/

String userMenuPath = "User/User/Select_User";
String username = "";
String userid = "";

addOnEvent("User/User/Login", "click", "login()");

// Returns a query to select all users
getUserQuery() {
    return "select userid, fname || ' ' || lname from user WHERE userdeleted is null;";
}

// Populates a user dropdown
populateListForUsers(){
    fetchAll(getUserQuery(), new FetchCallback() {
        onFetch(result) {
            populateDropDown(userMenuPath, result);
        }
    });
}

populateListForUsers();

login(){
    // Fetch user
    fetchOne("select userid,fname,lname,email from user where userid='" + getFieldValue(userMenuPath) + "';", new FetchCallback() {
        onFetch(result) {
            User user = new User(result.get(0),result.get(1),result.get(2),result.get(3));
            userid = result.get(0);
            setUser(user);
            username = result.get(1) + " " + result.get(2);
            showTabGroup("control");
        }
    });
}

/******************************************************************************/
/*                          TAKE FROM GPS BUTTON(S)                           */
/******************************************************************************/
/* Takes the current point using gps. */
takePoint(String rectypeTab, String tabgroup) {

  Object position = getGPSPosition();
  if (position == null) {
    showToast("{GPS_Not_Initialised}");
    return;
  }

  Object projPosition = getGPSPositionProjected();
  Double latitude     = position.getLatitude();
  Double longitude    = position.getLongitude();
  Double northing     = projPosition.getLatitude();
  Double easting      = projPosition.getLongitude();

  setFieldValue(tabgroup + "Longitude" , longitude );
  setFieldValue(tabgroup + "Latitude"  , latitude );
  setFieldValue(tabgroup + "Easting"   , easting );
  setFieldValue(tabgroup + "Northing"  , northing );

  samplePoint = new Point(new MapPos(easting, northing), null, (PointStyle) null, null);
  attachedGeometry = new ArrayList();
  attachedGeometry.add(samplePoint);

  saveAttachedGeometry( rectypeTab, "Accuracy: "+getGPSEstimatedAccuracy());
}

/******************************************************************************/
/*                                    INIT                                    */
/*                                                                            */
/* Stuff which needs to be done last.                                         */
/******************************************************************************/

setSyncDelay(10.0f);// increment delay 10 secs each time sync fails up to max
setSyncMinInterval(20.0f); // sync every 20 sec
setSyncMaxInterval(600.0f);

{{TEMPLATE_INIT_SYNC_AND_GPS}}


makeLocalID(){
  fetchOne("CREATE TABLE IF NOT EXISTS localSettings (key text primary key, value text);", null);
  fetchOne("DROP VIEW IF EXISTS parentchild;", null);
  fetchOne("CREATE VIEW parentchild AS "+
           "SELECT parent.uuid as parentuuid, child.uuid as childuuid, parent.participatesverb as parentparticipatesverb, parent.relationshipid, parent.aenttypename as parentaenttypename, child.participatesverb as childparticipatesverb, child.aenttypename as childaenttypename "+
           "  FROM (SELECT uuid, participatesverb, aenttypename, relationshipid"+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) parent "+
           "  JOIN (SELECT uuid, relationshipid, participatesverb, aenttypename "+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) child "+
           "    ON (parent.relationshipid = child.relationshipid AND parent.uuid != child.uuid);", null);
}
makeLocalID();


bindOnEvents();
