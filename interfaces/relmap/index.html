<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<title>Heurist generic relationship mapper</title>

<link rel=stylesheet type="text/css" href="styles.css">
<style>
img.icon { margin-right: 4px; }

.sliderInput {
  	height:20;
    width:40;
  	font-family : Arial, Helvetica, sans-serif;
	color:#003366;
  	font-size : 10px;
	align:middle;
  }


</style>

<script src="/heurist/php/js/load-hapi.php"></script>
<script src="/hapi/02/goi.js"></script>

<script src="http://maps.google.com/maps?file=api&amp;v=2.105&amp;key=ABQIAAAAGZugEZOePOFa_Kc5QZ0UQRQUeYPJPN0iHdI_mpOIQDTyJGt-ARSOyMjfz0UjulQTRjpuNpjk72vQ3w" type="text/javascript"></script>
<!--xscript src="main-105.js"></xscript-->
<script type="text/javascript" src="slider/lib/LibCrossBrowser.js"></script>
<script type="text/javascript" src="slider/lib/EventHandler.js"></script>
<script type="text/javascript" src="http://www.blueshoes.org/_bsJavascript/core/form/Bs_FormUtil.lib.js"></script>
<script type="text/javascript" src="http://www.blueshoes.org/_bsJavascript/core/gfx/Bs_ColorUtil.lib.js"></script>
<script type="text/javascript" src="slider/lib/Bs_Slider.class.js"></script>

<script src="RelationBrowser.js"></script>

<script>

// table of default value sets for various configurations.
var defaults = {
        0 : { center : "0.0,0.0",
                zoom : 15000,
                id:49,
                time : ["2000/1/1","2010/1/1"],
                timeBarBGif : 'slider_yardstick1.gif',
                interval: 0.05
        },
        mongolia : { center : "46.0,104.0",
                floatingCenter: [46,104],
                zoom : 1000,
                id:46754,
                time : ["1000/1/1","1500/1/1"],
                timeBarBGif : 'slider_yardstick2.gif' ,
                interval: 1
        },
        biofuel : { center : "52.0,10.0",
                floatingCenter: [56,4],
                zoom : 4000,
                id:10,
                time : ["1999/1/1","2010/1/1"],
                timeBarBGif : 'slider_yardstick1.gif' ,
                interval: 0.05
        },
        hist : { center : "52.0,10.0",
                zoom : 500,
                id:46746,
                time : ["-1000/1/1","2010/1/1"],
                timeBarBGif : 'slider_yardstick2.gif' ,
                interval: 5
        }
};

var app = {};                 //application object to contain all application level
app.map = {};

GMap2.prototype.cs = function(){this.Ef=true;if(this.ia()){this.nc(null,null,null)}};   // FIXME this needs to be commented

GMap2.prototype.zoomAndPan = function(bounds, newZoom) {
	var currentCenter = this.getCenter();
	var newCenter = bounds.getCenter();

	app.cacheMap.setZoom(newZoom);
	app.cacheMap.setCenter(newCenter);

	var currentZoom = this.getZoom();

	if (newZoom > currentZoom) {
		// Need to zoom in

		for (var i=currentZoom+1; i <= newZoom; ++i) {
			setTimeout(makeNewTimeoutFunction(newCenter, true, 300 * (i - (currentZoom+1))));
		}

		var handle = GEvent.addListener(app.map, "zoomend", function(_, endZoom) {
			if (endZoom != newZoom) { return; }
			GEvent.removeListener(handle);
		});
	}
	else if (newZoom < currentZoom) {
		// Need to zoom out

		/* This can get complicated:
		 * Google Maps' smooooooth animation (continuous zoom) goes ugly if the
		 * "focus point" of the zoom out is not actually visible
		 * (i.e. within the bounds of the map)
		 * So, we use a series of midpoints at geometrically increasing intervals.
		 */

		var totalN = (1 << (currentZoom - newZoom)) - 1;
		var n = 0, nIncrement = 1;
		for (var i=currentZoom-1; i >= newZoom; --i) {
			n += nIncrement;
			nIncrement *= 2;
			setTimeout(makeNewTimeoutFunction(calculateMidwayPoint(currentCenter, newCenter, n / totalN), false, 300 * ((currentZoom+1) - i)));
		}
		var handle = GEvent.addListener(app.map, "zoomend", function(_, endZoom) {
			if (endZoom != newZoom) { return; }
			GEvent.removeListener(handle);
			app.map.panTo(newCenter);
		});
	}
	else {
		if (! app.map.fromLatLngToDivPixel(newCenter).equals(app.map.fromLatLngToDivPixel(currentCenter))) {
			app.map.panTo(newCenter);
		}
		else {
			/* we don't have to move at all -- we're all done, stop the loading animation */
			moveEndCallback();
		}
	}
};


/*****************DISPLAY MANAGER***********************
*
*
*
*
*
*******************************************************/
function DisplayManager(inMap) {
    if (inMap.displayManager) {
        return inMap.displayManager;
    }    // only want a single manager per map

    /**********private***************/
    /**
     *  Container for markers, affinity groups and clusters
     *
     *  @property _markers
     *  @type  object
     *  @private
     */
    var _markers = [];

    /**********private***************/
    /**
     *  Container for relationship Markers
     *
     *  @property _relationMarkers
     *  @type  object
     *  @private
     */
    var _relationMarkers = [];


    /**********private***************/
    /**
     *  Location index map for locatedmarkers
     *
     *  @property _mappedmarkers
     *  @type  object
     *  @private
     */
    var _mappedMarkers = {};

    /**********private***************/
    /**
     *  Location index map for clusters
     *
     *  @property _clusters
     *  @type  object
     *  @private
     */
    var _clusters = {};

    /**
     *  Reference to the focus record
     *
     *  @property _focusRecord
     *  @type  HRecord
     *  @private
     */
    var _focusRecord = null;

    /**
     *  search depth for realtionship record set
     *
     *  @property _relationDepth
     *  @type  int
     *  @private
     */
    var _relationDepth = 1;

    /**
     *  This function removes all the Markers  from the map and deletes them
     *
     *  @method _unloadMarkers
     *  @type  function
     *  @private
     */
    function _unloadMarkers() {
      _mappedMarkers = {};

      for (index in _clusters){
        _clusters[index].prepForDelete();
        delete _clusters[index];
      }
      _clusters = {};

      var len = _markers.length,
          i;
      for (i=0; i < len; i++){
        _markers[i].prepForDelete();
        delete _markers[i];
      }
      _markers =[];

      len = _relationMarkers.length;
      for (i=0; i < len; i++){
        _relationMarkers[i].prepForDelete();
        delete _relationMarkers[i];
      }
      _relationMarkers = [];
    }
    /**
     *  This function loads the Markers for all related records to the current depth for the currect focus record. Then it displays them on the map
     *
     *  @method _loadMarkers
     *  @type  function
     *  @private
     */
    function _loadMarkers() {
        var newMarker = null;
            // clear marker array
        _markers = [];
            // if the focus record needs a marker create it and add it to markers array and show the marker
        if (!_focusRecord.marker) {
            newMarker = new RecordMarker(_focusRecord,that);     //the new was left in for readability, it's not required
        }
        _markers.push(_focusRecord.marker);
        _focusRecord.marker.show();
            // get the related records recursively to the relationDepth
        _processRelated(_focusRecord,1);  //call with the top level record which has a depth of 0 but we must call with the depth we want.

            //create a marker location indexed map/array
        var i,
            location, index,
            len = _markers.length;
        for( i=0; i<len; i++){
             location =_markers[i].getLocation();
                //for each marker with a location
             if (location){
                 index = location.lat() + "," + location.lng();       // FIXME  we should apply a percision to this so this works for zoom-out
                 // if there isn't an index for this location make one
                 if (!_mappedMarkers[index]){
                    _mappedMarkers[index] = [_markers[i]];
                 }else{
                    var exists = false,
                        id = _markers[i].getID();
                    for (var j = 0; j < _mappedMarkers[index].length; j++) {
                        if (_mappedMarkers[index][j].getID() == id) {
                            exists = true;
                            break;
                        }
                    }
                    if (! exists) {
                        _mappedMarkers[index].push(_markers[i]);
                    }
                 }
             }
        }
    /*  Create clusters */
        for (index in _mappedMarkers){
            // for each entry in the map that has more that one marker
            var len =  _mappedMarkers[index].length ;
            if ( len > 1){
                //create a cluster mark
                _clusters[index] = new ClusterMarker(_mappedMarkers[index][0].getLocation(),index,that);
                //add all markers to it
                for (var i=0; i<len; i++){ _clusters[index].addMarker(_mappedMarkers[index][i])};
                //recalc the positions
                // since the cluster is created collapsed there is no need to  recalcLayout  _clusters[index].recalcLayout();
                //show the cluster on the map
                _clusters[index].show();
            }
        }

        _processRelations(_focusRecord,1);

    }

        function _processRelations(record, depth){
            if (depth > _relationDepth) return;   //safety for stopping recursion
            var relRecs = record.getRelatedRecords();
            var relRecIDs = [];
            var relations = record.getRelationships();
            var i,
                len = relations.length,
                recID = record.getID();

            for (i=0; i<relRecs.length; i++) relRecIDs[relRecs[i].getID()] = 1;
            //for each relationship
            for (i=0; i<len; i++){
                // if it's not a primary relationship we skip it
                if ( !(relations[i].getPrimaryRecord().getID() in relRecIDs) && !(relations[i].getSecondaryRecord().getID() in relRecIDs)) continue;
                //if it doesn't have a marker create one
                if (!relations[i].marker) {
                    newMarker = new RelationMarker(relations[i],that);     //the new was left in for readability, it's not required
                }
                //add the marker to the markers array : note that the marker is attached to the record during construction
                _relationMarkers.push(relations[i].marker);
                // determine directionality of this relation
                if (relations[i].getPrimaryRecord().getID() == record.getID()) {
                    //record is primary so attach secondary
                    relations[i].marker.setAttachment(2);
                } else{
                    //record is secondary so attach primary
                    relations[i].marker.setAttachment(1);
                }
                //show the marker
                relations[i].marker.show(record.marker);

               //if the current processing depth is less than the relationDepth then process the next level
                if(depth < _relationDepth)           //FIXME  need to check secondary record depth against _relation Depth and processing depth to stop loops
                    _processRelations(relations[i].getSecondaryRecord().getRecord(), depth+1);
            }
        }


    function _processRelated(record, depth){
            if (depth > _relationDepth) return;   //safety for stopping recursion
            var relRecs = record.getRelatedRecords();
            var i,
                len = relRecs.length;
            //for each related record
            for (i=0; i<len; i++){
                //if it doesn't have a marker create one
                if (!relRecs[i].marker) {
                    newMarker = new RecordMarker(relRecs[i],that);     //the new was left in for readability, it's not required
                }
                //add the marker to the markers array : note that the marker is attached to the record during construction
                _markers.push(relRecs[i].marker);
                //set the markers relationDepth
                relRecs[i].marker.setDepth(depth);  //FIXME  need to check for minimum of current markerDepth with depth since there might be multiple relation paths
                //show the marker
                relRecs[i].marker.show();
                //if the record doesn't have a location
                if(!(relRecs[i].locations && relRecs[i].locations[0])) {
                     var rT = typeof record.marker
                     if (rT == "object") {
                        //check if there is an affinity group for the parent record
                       //if there isn't an affinity group for the parent record
                        if (!record.marker.affinityGroupMarker){
                            //create one, attach it to the parent record
                            var temp = new AffinityGroupMarker(record.marker,that) ;
                        }
                        //add this record to the affinity group of the parent record
                        record.marker.affinityGroupMarker.addMarker(relRecs[i].marker);
                        //set the displayLocation to the parents displayLocation
     //                   relRecs[i].marker.setDisplayLocation(record.marker.getDisplayLocation());
                   }else{
               //        assert("Error, there must be a marker for a record before you can make an affinity group. ");
                   }
                }
                //if the current processing depth is less than the relationDepth then process the next level
                if(depth < _relationDepth)
                    _processRelated(relRecs[i], depth+1);
            }
        }


/************  public interface for displayManager ********************/
    var that = {
        /**
         *  Reference to the display palette
         *
         *  @property map
         *  @type  GMap2
         *  @public
         */
       map: inMap,

       /****
        *  @method  setFocus
        *  @param    { HRecord} record   HRecord that has the focus of the relationship display
        *
        *******/
       setFocus : function(record) {
           if (!record) return;
           if (_focusRecord && _focusRecord.marker) _focusRecord.marker.setZIndexOffset(0);
           _focusRecord = record;
           if (_focusRecord.marker) {
                _focusRecord.marker.setZIndexOffset(20000);
                _focusRecord.marker.setDepth(0);
           }else{
               //TODO need to set during load. need to use (multi?) event model
           }
           _unloadMarkers();
       },
       /****
        *  @method  getFocus
        *  @return    { HRecord} record   HRecord that has the focus of the relationship display
        *
        *******/
       getFocus : function() {
            return _focusRecord;
       },

       /****
        *  @method  getMaxDepth
        *  @return  {int} _relationDepth
        *******/
       getMaxDepth : function() {
            return _relationDepth;
       },

       /****
        *  @method  applyFilter
        *
        *******/
       applyFilter : function(filter) {
          // two algorithms - apply the filter to the focus record so it can apply to it's relationships
          //                - apply only to relationship Markers
          var len = _relationMarkers.length,
              i;
          if (len){
            for (i=0; i < len; i++){
                _relationMarkers[i].applyFilter(filter);
            }
          }
       },
       /****
        *  @method  clearMap
        *
        *******/
       clearMap : function() {
           _unloadMarkers();
       },

        /****
        *  @method  onZoomEnd
        *
        *******/
       onZoomEnd : function() {
             for(var i=0; i < _markers.length; i++){
                if (_markers[i].affinityGroupMarker)  _markers[i].affinityGroupMarker.recalcLayout();
             }
       },

      /****
        *  @method  plotRecordset
        *
        *******/
       plotRecordset : function() {
           app.map.zoomAndPan(app.bounds, Math.min(app.map.getBoundsZoomLevel(app.bounds), 13));
            _loadMarkers();
       }
    };
/******* displayManager object binding code *************
 * This code must come after the declaration of the public interface variable that
 *
 * here we setup a reverse pointer from the map object to the display manager
 * and set the zoomend event handler to redrawExpanded nodes since the scale has changed
 *
 */

    inMap.displayManager = that;

    GEvent.bind(inMap, "zoomend", that, that.onZoomEnd);


    return that;
}


/**********************   end of Display Manager ***************************/



function calculateMidwayPoint(point1, point2, fraction) {
	/* calculate the point some fraction of the way between point1 and point2 */
	return new GLatLng(fraction * point2.lat() + (1-fraction) * point1.lat(),
	                   fraction * point2.lng() + (1-fraction) * point1.lng());
}

function makeNewTimeoutFunction(center, zoomIn) {
	return function() {
		if (zoomIn) {
			//app.map.ok(1, true, center, true);
		}
		else {
			//app.map.ok(-1, true, center, true);
		}
	}
}



app.load =function() {
	if (! HCurrentUser.isLoggedIn()) {
		// need to use the host as found in the first line of code at the top of this script to make sure
		// users are redirected to the correct login
		//alert("You are not logged in to Heurist.\nRedirecting you now ...");
		//location.replace("http://"+window.location.host+"/heurist/php/login.php?last_uri=" + encodeURIComponent(location.href));
	}
	// only in the general EUProjects implementation is this required
	//else if (! HCurrentUser.isInWorkgroup(HWorkgroupManager.getWorkgroupById(19))) {
	//	alert("You are not in the EUProject workgroup.\nSome records may not be visible to you.");
	//}

	if (GBrowserIsCompatible()) {
		// preload images
		app.cacheMap = new GMap2(document.getElementById("cache-map"));
		app.cacheMap.setCenter(new GLatLng(parseFloat(app.center[0]), parseFloat(app.center[1])), parseInt(app.zoom));
		app.cacheMap.setMapType(G_PHYSICAL_MAP);

		app.map = new GMap2(document.getElementById("map"));
		app.map.enableDoubleClickZoom();
		app.map.enableContinuousZoom();
		app.map.enableScrollWheelZoom();
		app.map.addControl(new GSmallMapControl());
		app.map.setCenter(new GLatLng(parseFloat(app.center[0]), parseFloat(app.center[1])), parseInt(app.zoom));
		app.map.setMapType(G_PHYSICAL_MAP);
		GEvent.addListener(app.map, "moveend", moveEndCallback);

		app.displayManager = new DisplayManager(app.map);
	}

	loadAllRecords("id:"+app.initialID + " OR relationsfor:" + app.initialID + " type:52 OR relationsfor:" + app.initialID + " " + app.filter , null,
        new HLoader(
		    function(search, records) {
			    var focus = -1;
                for (var i=0; i < records.length; ++i) {
                    processNewRecord(records[i]);
                    if ( focus < 0 && records[i].getID() == app.initialID) focus = i;
                }
                if (focus<0) focus = 0;
			    if (records[focus]){
                    app.displayManager.setFocus(records[focus]);
                    records[focus].relatedLoaded = true;
			        // TODO write code to load records for relationDepth
                    app.chooseRecord(records[focus]);
                }
		    },
		    function(search, error) {
			    alert("search failed: " + error);   //FIXME  alert doesn't seem to work, we need to add a page to show failure
		    }
        )
    );

}


function checkForLocation(hRecord) {
    if (!app.bounds) app.bounds = new GLatLngBounds();
    if (!HAPI.isA(hRecord,"HRelationship")) {
        var geos = hRecord.getDetails(HDetailManager.getDetailTypeById(230));
        hRecord.locations = [];
        var len = geos.length;
        var point;
        for (var i=0; i < len; ++i) {
            point = new GLatLng(parseFloat(geos[i].getY()), parseFloat(geos[i].getX()));
      //      point.depth = vals[bibID][i][2];
            hRecord.locations.push(point);
            app.bounds.extend(point);
        }
    }
}

//added by nan li for search
var nancheck=1; //nan
function doSearch() {
    nancheck=1;
	legendCheck=2;
    tempKnownRecordIDs = knownRecordIDs;
    knownRecordIDs = null;
	var loader = new HLoader(
			function(s,r) {
				displayResults(r);
			},
			function(s,e) {
				alert("load failed: " + e);
			});
	loadAllRecords(document.getElementById("search-string").value + " -type:52", null, loader);
    knownRecordIDs = tempKnownRecordIDs;
}

function displayResults(r) {
	document.getElementById("searchresults").style.display='block';
	document.getElementById("contentframe").style.display='none';
	document.getElementById("clear-search").style.display='';

	var div = document.getElementById("searchresults");
	//div.style.height = "0px";
	//div.style.height = (document.getElementById("contentcell").offsetHeight )+"px";
	//document.getElementById("legendlink").style.display = '';
	div.innerHTML = "";
	for (var i = 0; i < r.length; i++) {
		addRelatedRecordLink(div,r[i]);
        processNewRecord(r[i]);                                   //mark this record id as loaded
	}
	div.style.overflow='auto';
}

function clearSearchResult(){
	//document.getElementById("searchresults").innerHTML="";

    document.getElementById("clear-search").style.display='none';
	document.getElementById("searchresults").style.display='none';
	document.getElementById("contentframe").style.display='block';         //relationtype

}

// added by nan for search

//the following function is used to load timeline
var mySlider;
function initslider() {
             var matches = app.timeBarRange[0].match(/(-?\d+)/g);  // get the start date of the timeBar
             var start = parseInt(matches[0]) + ( matches[1] ? app.getFractionalYear(matches[1],matches[2]? matches[2] : 1)/100 : 0);
             matches = app.timeBarRange[1].match(/(-?\d+)/g);  // get the end date of the timeBar
             var end = parseInt(matches[0]) + ( matches[1] ? app.getFractionalYear(matches[1],matches[2]? matches[2] : 1)/100 : 0);
 			 mySlider = new Bs_Slider();
 			 mySlider.width         = 420;
 			 mySlider.height        = 25;
 			 mySlider.imgDir   = "slider/";
 			 mySlider.setBackgroundImage(app.defaults.timeBarBGif, 'no-repeat');
			 mySlider.attachOnChange (timeChange);
			 mySlider.attachOnInputChange (timeChange);
			// mySlider.attachOnInputBlur (timeChange);

 			 mySlider.fieldName     = "slider_start";
 			 mySlider.minVal        = start;
 			 mySlider.maxVal        = end;
 			 mySlider.valueInterval = 0.05;              // FIXME  need to try 1/12 values
 			 mySlider.valueDefault  = minValue;
 			 mySlider.setSliderIcon('slider2.gif', 13, 25);
 			 mySlider.useInputField = 3;
 			 mySlider.styleValueFieldClass = "sliderInput";

			 mySlider.useSecondKnob        = true;
			 mySlider.preventValueCrossing = true;
			 mySlider.wheelAmount        = 0; //disable mouse wheeling cause we have 2 knobs.

			 mySlider.fieldName2     = "slider_end";
  			 mySlider.minVal2        = start;
  			 mySlider.maxVal2        = end;
 			 mySlider.valueInterval2 = 0.05;             // FIXME  need to try 1/12 values
 			 mySlider.valueDefault2  = maxValue;
			 mySlider.setSliderIcon2('slider2.gif', 13, 25);
 			 mySlider.useInputField2 = 3;
 			 mySlider.styleValueFieldClass2 = "sliderInput";

			mySlider.colorbar = new Object({ type:'between', color:'#6699CC', offsetLeft:6, height:11, offsetTop:12});




 			 mySlider.drawInto('my-timeline');
	//		 loadRelationships();
		}


function loadRelationships(){
    var relRecords=app.displayManager.getFocus().getRelatedRecords();
    var recIDs = []
    for (var i=0; i<relRecords.length;i++) {
         if(relRecords[i].getRecordType().getID() != 52 && !relRecords[i].relatedLoaded){
                recIDs.push(relRecords[i].getID());
         }
    }

    function loader(s,r){
        for (var i=0; i<relRecords.length;i++) {
                relRecords[i].relatedLoaded = true;
        }
    }

    HeuristScholarDB.loadRecords(new HSearch("relationsfor:"+ recIDs.join("'"),
                      new HLoader(loader)));

/*  for (var i=0; i<relRecords.length;i++) {
	     if(relRecords[i].getRecordType().getID() != 52){
		     if(!relRecords[i].relatedLoaded){
                var recID = relRecords[i].getID();
				HeuristScholarDB.loadRecords(new HSearch("relationsfor:"+ recID),  //FIXME  should be able to ask for all the records
                                  new HLoader(function(s,r){ }));
             }
		 }
	}
    */
}

function timeChange() {
		var startDate, endDate;
		if (document.getElementById("filter").checked) {
			startDate = Number(mySlider.getValue(1));
			endDate = Number(mySlider.getValue(2));
            var timeFilter = new Filter();
            timeFilter.setStartDate(startDate);
            timeFilter.setEndDate(endDate);
            app.displayManager.applyFilter(timeFilter);
		}
        minValue = Number(mySlider.getValue(1));
        maxValue = Number(mySlider.getValue(2));
}


/**************************************************
 * getFractionalYear
 * @month   - integer between 1 and 12
 * @day     - date within the range of the given >= 1  and  <= monthDays[month]
 *
 * @return  - returns a integer between 0 and 99 indicating the fraction 100th's of a year
 **************************************************/
app.getFractionalYear = function(month,day) {
    var monthDays = [31,29,31,30,31,30,31,31,30,31,30,31];
    if (month < 1 || month > 12 ) return 0;
    var ret = 0;
    for (i=0; i < month-1; i++) ret += monthDays[i];
    if (day >= 1 && day <= monthDays[month]) ret += parseInt(day);
    return Math.floor(ret*100/366);
}


function changeDateFormat(startdate){
    if(startdate){
	var monthname=new Array("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
	var syear = startdate.substring(0,4);

	var smonth= startdate.substring(5,7);
	if(smonth.charAt(0)=="0")
	   smonth = smonth.substring(1,2);

	var sday= startdate.substring(8,10);

    var sdate = monthname[smonth-1]+" "+sday+" "+syear+" 00:00:00 GMT";
	return sdate;
	}
	else
	return;

}

//this function is used to get min start date from a bunch of projects
function getMinDate(startArr){

	startArr.sort();
	return startArr[0];
}

//this function is used to get max end date from a bunch of projects
function getMaxDate(endArr){

	endArr.sort();
	return endArr[endArr.length-1];
}
//build a function to replace all string in one variable.
 function replaceAll(str,from,to) {

    var idx=str.indexOf(from);  //get the index of from in str
    //replace all from in str to to
    while(idx>-1) {
        str=str.replace(from,to);
        idx=str.indexOf(from);
    }

    return str;

}

</script>

<script>
app.googleZoomFromKm = function(km,lat) {
            if (lat < 0) lat = - lat;
            var degreeMeters = [2.4,2.4,2.4,2.3,2.2,2.2,2.1,2.0,1.8,1.7,1.5,1.4,1.2,1.0,0.8,0.6,0.4,0.2];
            var zf = 15,
                seed = degreeMeters[ Math.floor(lat/5)];  // the seed values are kilometers displayed (zoom = 15) at degrees lng for every 5 degrees starting at 0
            while (seed < km && zf > 0) {
                 seed = seed * 2;
                 zf = zf-1;
            }
            return zf;
};

app.compDates = function(d1,d2){
    a = d1.match(/(\d+)/g);
    b = d2.match(/(\d+)/g);
    if (!a || !b) return null;
    if (a[0] && b[0]) {
        if( parseInt(a[0]) < parseInt(b[0])) return -1;
        if( parseInt(a[0]) > parseInt(b[0])) return 1;
    }
    if (a[1] || b[1]) {
        if( parseInt(a[1]||1) < parseInt(b[1]||1)) return -1;
        if( parseInt(a[1]||1) > parseInt(b[1]||1)) return 1;
    }
    if (a[2] || b[2]) {
        if( parseInt(a[2]||1) < parseInt(b[2]||1)) return -1;
        if( parseInt(a[2]||1) > parseInt(b[2]||1)) return 1;
    }
    return 0;
};

var matches = window.location.search.match(/default=([^&#]+)/);
app.defaults =   matches && matches[1] && defaults[matches[1]] ? defaults[matches[1]] : defaults["mongolia"];
matches = window.location.search.match(/filter=([^&#]+)/);
app.filter =   matches && matches[1] ? matches[1] : "";
matches =  window.location.search.match(/id=(\d+)/);
app.initialID =  matches && matches[1] ? matches[1] : app.defaults.id;
app.initialDepth =  window.location.search.replace(/.*depth=(\d+).*/, "$1") || 1;
matches = window.location.search.match(/time=([^&#,a-z]+),([^&#,a-z]+)/);
app.timeBarRange = [(matches && matches[1] ? matches[1] : app.defaults.time[0]),(matches && matches[2] ? matches[2] : app.defaults.time[1])];
matches = window.location.search.match(/timeFilter=([^&#,a-z]+),([^&#,a-z]+)/);
app.timeFilterRange = [(matches && matches[1] ? matches[1] : app.timeBarRange[0]),(matches && matches[2] ? matches[2] : app.timeBarRange[1])];
if (app.compDates(app.timeFilterRange[0], app.timeBarRange[0]) == -1)  app.timeBarRange[0] = app.timeFilterRange[0];
if (app.compDates(app.timeFilterRange[1], app.timeBarRange[1]) == 1)  app.timeBarRange[1] = app.timeFilterRange[1];
matches = window.location.search.match(/(?:centre|center)=([^&#]+)/);
app.center =  (matches && matches[1] ? matches[1] : app.defaults.center).split(",");
matches =  window.location.search.match(/zoom=(\d+)/);
app.zoom = matches && matches[1] ? matches[1] : app.defaults.zoom;
app.zoom = app.googleZoomFromKm(app.zoom, app.center[0]);  // convert Km to google zoom level
var chosenRecord = null;
var recordStack = [];	// a list of all the previous records that have been visited
var recordStackIndex = 0;
matches = app.timeFilterRange[0].match(/(-?\d+)/g);  // get the start date of the timeBar
var minValue = parseInt(matches[0]) + ( matches[1] ? app.getFractionalYear(matches[1],matches[2]? matches[2] : 1)/100 : 0);
matches = app.timeFilterRange[1].match(/(-?\d+)/g);  // get the end date of the timeBar
var maxValue = parseInt(matches[0]) + ( matches[1] ? app.getFractionalYear(matches[1],matches[2]? matches[2] : 1)/100 : 0);

var relatedDepth = 0;
var knownRecordIDs = [], knownRecordIDsMap = {};
//HAPI ids commonly used
app.startDateFieldID = HDetailManager.getDetailTypeById(177);
app.endDateFieldID = HDetailManager.getDetailTypeById(178);
app.geoField = HDetailManager.getDetailTypeById(230);
app.orgTypeField = HDetailManager.getDetailTypeById(364);	// actually category!

function processNewRecord(record) {
	var id = record.getID();
	if (! knownRecordIDsMap[id]) {
		knownRecordIDsMap[id] = true;
		knownRecordIDs.push(id);
        checkForLocation(record);
//        recordType = record.getRecordType().getID();
    }
}

// restrict all searches, loads etc to just the records that have not been loaded, This hooks the normal behavior of HAPI.Search
var BaseSearch = HSearch;
HAPI.Search = HSearch = function(query, options) {
	// don't reload known records
	var excludeIDs = "";
	if (knownRecordIDs) { excludeIDs = "-ids:" + knownRecordIDs.join(",") + " "; }  //create exclusion clause
	BaseSearch.call(this, query+" "+excludeIDs, options);
};
HSearch.getClass = function() { return "HSearch"; };
HAPI.inherit(HSearch, BaseSearch);


function chooseRecordCallback() {
	// Callback for GMarker: used with GEvent.bind such that (this) is an HRecord
	app.chooseRecord(this);
}


app.chooseRecord = function(record, dontAlterStack) {
// setup title area for the focus record
	var crt = document.getElementById("current-record-title");
	var crl = document.getElementById("current-record-link");
	var cri = document.getElementById("current-record-image");
    var rrList = document.getElementById("other-records");
    var cs = document.getElementById("clear-search");
    if (cs.style.display != "none") clearSearchResult();

	crt.innerHTML = "";
	rrList.innerHTML = "Loading ...";
	document.getElementById("loading-div").style.display = "block";

	crt.appendChild(document.createTextNode(record.getTitle()));
	crl.href = "detail.html?id=" + record.getID();
	var orgType = record.getDetails(app.orgTypeField);
	if (orgType  &&  orgType[0]) {
		cri.src = app.getOrgTypeIconPath(orgType[0], false);
	} else {
		cri.src = "http://heuristscholar.org/heurist-test/img/reftype/" + (record.getRecordType().getID() || "questionmark") + ".gif";
	}
	cri.style.display = "";
	cri.style.verticalAlign = "baseline";

    app.displayManager.setFocus(record);
	if (! dontAlterStack) {
		// The record stack keeps track of which records we've previously chosen,
		// but in order to navigate back and forth between records already on the stack we need an override
		// (see gotoPreviousRecord and gotoNextRecord)

		if (recordStackIndex+1 >= recordStack.length) {
			// easy case: we are already looking at the last record on the stack, push the new record on the end
			recordStack.push(app.displayManager.getFocus());
		}
		else {
			// harder case: there are other records lurking on the stack ABOVE (not including) our current position,
			// and we want to replace those all with one single record (the new record)
			recordStack.splice(recordStackIndex+1, recordStack.length-recordStackIndex-1, app.displayManager.getFocus());
		}
		recordStackIndex = recordStack.length-1;
	}

	relatedDepth = 0;
	if (! app.displayManager.getFocus().relatedLoaded) {
		++relatedDepth;
//sm.loadRecords(new HSearch("relatedto:"+_id+" OR linkto:"+_id+" OR linkedto:"+_id), loader);
                //sm.loadRecords(new HSearch("relationsfor:"+_id), loader);
        app.displayManager.getFocus().relatedLoaded = true;

		loadAllRecords("relationsfor:"+ app.displayManager.getFocus().getID() + " type:52 relationsfor:" + app.displayManager.getFocus().getID() + " " + app.filter, null, new HLoader(addAllRelatedLinks));

//		chosenRecord.loadRelated(HeuristScholarDB, new HLoader(addAllRelatedLinks));
	}
	else {
		addAllRelatedLinks();

	}
}


function loadAllRecords(query, options, loader) {
	var records = [];
	var baseSearch = new HSearch(query, options);
	var bulkLoader = new HLoader(
		function(s, r) {	// onload
			records.push.apply(records, r);
			if (r.length < 100) {
				// we've loaded all the records: invoke the loader's onload
				loader.onload(baseSearch, records);
			}
			else {
				// might be more records to load: do a search with an offset specified
				var search = new HSearch(query + " offset:"+records.length, options);
				HeuristScholarDB.loadRecords(search, bulkLoader);
			}
		},
		loader.onerror
	);
	HeuristScholarDB.loadRecords(baseSearch, bulkLoader);
}


var legendCheck = 2; //this var is used to set the height of contentframe

//create legend code
function addAllRelatedLinks(search, recordSet) {
 //   app.displayManager.clearMap();

	var i;
	if (search) {
     //   app.bounds = undefined;   // processNewRecords will calc a new bounding box
		for (i=0; i < recordSet.length; ++i) { processNewRecord(recordSet[i]); }
	}

    app.displayManager.plotRecordset();
	relatedDepth = 0;

	var rrList = document.getElementById("other-records");
	rrList.innerHTML = "&nbsp;";

/*	document.getElementById("contentframe").style.height="0px";
	if(legendCheck<2)  //when the page is loaded first time
	    document.getElementById("contentframe").style.height =  (document.getElementById("contentcell").offsetHeight+15) + "px";
	else{
		//document.getElementById("legend").style.display='none';
		//document.getElementById("legendlink").style.display = '';
		document.getElementById("contentframe").style.height =  (document.getElementById("contentcell").offsetHeight+15 )+"px";
	}
	 if(nancheck == 1){
		document.getElementById("searchresults").style.height = "0px";
		document.getElementById("searchresults").style.height =  (document.getElementById("contentcell").offsetHeight+50 )+"px";
	}*/
//	legendCheck++;

	var rrlistSear=document.getElementById("searchresults"); //nan
	rrlistSear.innerHTML=""; //nan

	rrList.innerHTML = "";

	var relnType;
	var relations, relationsByType, recordTypes, relns;
	var list;
	var relRec, recType, relType;

	relations = app.displayManager.getFocus().getRelationships();

	if (relations.length > 0) {
		relationsByType = {};
		recordTypes = [];

		for (i=0; i < relations.length; ++i) {
			if (relations[i].getPrimaryRecord().getID() === app.displayManager.getFocus().getID()) {
			    relRec = relations[i].getSecondaryRecord().getRecord();
				if(!relRec) continue;
				relType = relations[i].getType();
				recType = relRec.getRecordType().getID();
			}
			else {
				relRec = relations[i].getPrimaryRecord().getRecord();
				if(!relRec) continue;
				relType = relations[i].getInverseType();
				recType = relRec.getRecordType().getID();
			}
			if (! relRec) { continue; }

			var hasDuplicated = false;
			if (relationsByType[recType]) {
				if (relationsByType[recType][relType]) {
				    for(var z=0;z<relationsByType[recType][relType].length;z++){
					    if(relationsByType[recType][relType][z]==relRec){       // FIXME?  should we compare IDs
						    hasDuplicated = true;                             //get rid of duplicated record
						    break;
						}

					}
					if(!hasDuplicated){
					   relationsByType[recType][relType].push(relRec);
					   }

				}
				else {
					relationsByType[recType][relType] = [ relRec ];
				}
			}
			else {
				recordTypes.push(recType);
				relationsByType[recType] = {};
				relationsByType[recType][relType] = [ relRec ];
			}
		}

		recordTypes.sort(function(a,b){return a-b;});
		for (var j=0; j < recordTypes.length; ++j) {
		    recType = recordTypes[j];

		    rrList.appendChild(document.createElement("hr"));
//			if(nancheck==1)
//			rrlistSear.appendChild(document.createElement("hr"));  //nan

		    for (relnType in relationsByType[recType]) {
			relns = relationsByType[recType][relnType];
			relns.sort(strcmp);


			var newDiv = document.createElement("div");
			newDiv.className = "relation_type";
			newDiv.appendChild(document.createTextNode(relnType));
			rrList.appendChild(newDiv);

			//added by nan to add relation type, such as  "is related to"
			var newDiv1 = document.createElement("div");
			newDiv1.className = "relation_type";
			newDiv1.appendChild(document.createTextNode(relnType));
//			if(nancheck==1)
//			rrlistSear.appendChild(newDiv1); //nan


			for (i=0; i < relns.length; ++i) {
				addRelatedRecordLink(rrList, relns[i]);
//				if(nancheck==1)
//				addRelatedRecordLink(rrlistSear,relns[i]);  //nan
			}

			rrList.appendChild(document.createElement("br"));
//			if(nancheck==1)
//			rrlistSear.appendChild(document.createElement("br")); //nan
		    }
		}
	}

	else {
		rrList.innerHTML = "<i>No related records</i>";
		rrlistSear.innerHTML = "<i>No related records</i>"; //nan
	}

	document.getElementById("filter").checked = true;
    document.getElementById("filter").style.display = "none";

	initslider();  // load timeline for a record that has "project" relationship
}

function strcmp(a,b) { var x = a.getTitle(), y = b.getTitle(); return (x < y)? -1 : (x > y)? 1 : 0; }

// add legend entry code
function addRelatedRecordLink(rrList, record) {
	var newTable = document.createElement("table");
	newTable.className = "resource_table";
	var newTr = newTable.appendChild(document.createElement("tbody")).appendChild(document.createElement("tr"));

	var newTd1 = newTr.appendChild(document.createElement("td"));
	var newTd2 = newTr.appendChild(document.createElement("td"));
	var newTd3 = newTr.appendChild(document.createElement("td"));

	var newA1 = newTd1.appendChild(document.createElement("a"));
	newA1.title = "Edit resource details";
    //set the link to call the heurist edit page with this record's id and select the relationship tab
	newA1.href = 'http://' + window.location.host + '/heurist/edit?bib_id='+record.getID() + '#relationships';
    // make sure that it comes up in another tab
    newA1.target = '_blank';
	var newImg = newA1.appendChild(document.createElement("img"));
	var orgType = record.getDetails(app.orgTypeField);
	if (orgType  &&  orgType[0]) {
		newImg.src = app.getOrgTypeIconPath(orgType[0], false);
	} else {
		newImg.src = "http://heuristscholar.org/heurist/img/reftype/" + (record.getRecordType().getID() || "questionmark") + ".gif";
	}
	newImg.className = "icon";

	var newA2 = newTd2.appendChild(document.createElement("a"));
	newA2.className = "resource_link";
	newA2.title = "Change focus to this related record";
	newA2.href = "#";
	newA2.onclick = function() {
		app.chooseRecord(record);

		return false;
	};
	newA2.appendChild(document.createTextNode(record.getTitle()));

	if (record.getURL()) {
		var newA3 = newTd3.appendChild(document.createElement("a"));
		newA3.title = "View record URL";
		newA3.target = "_blank";
		newA3.href = record.getURL();
		var newImg = newA3.appendChild(document.createElement("img"));
		newImg.src = "http://heuristscholar.org/heurist-test/img/external_link_16x16.gif";
		newImg.className = "icon";
	}

	rrList.appendChild(newTable);
}

// back button for relation browsing
function gotoPreviousRecord() {
	if (recordStackIndex === 0) { return; }	// no previous record

	var previousRecord = recordStack[--recordStackIndex];
	app.chooseRecord(previousRecord, /* dontAlterStack = */ true);
}
//forward button for relation browsing
function gotoNextRecord() {
	if (recordStackIndex+1 >= recordStack.length) { return; }	// no "next" record

	var nextRecord = recordStack[++recordStackIndex];
	app.chooseRecord(nextRecord, /* dontAlterStack = */ true);
}




var markers = [];
var lines = [];
var addRemoveFlag=[]; //added by nan
app.iconsByOrgType = {
         "Assoc London": "http://heuristscholar.org/relmap/img/AssocLondon.png",
         "Assoc other":  "http://heuristscholar.org/relmap/img/AssocOther.png",
         "Business London":"http://heuristscholar.org/relmap/img/BusinessLondon.png",
         "Business other": "http://heuristscholar.org/relmap/img/BusinessOther.png",
         "FE London": "http://heuristscholar.org/relmap/img/FELondon.png",
         "FE other": "http://heuristscholar.org/relmap/img/FEOther.png",
         "HE other": "http://heuristscholar.org/relmap/img/HEother.png",
         "London Higher": "http://heuristscholar.org/relmap/img/HELondon.png",
         "London Higher Parent": "http://heuristscholar.org/relmap/img/HELondon.png",
         "Res London": "http://heuristscholar.org/relmap/img/ResLondon.png",
         "Res other": "http://heuristscholar.org/relmap/img/ResOther.png",
         "default": "http://heuristscholar.org/relmap/img/ResOther.png"
};
app.gifsByOrgType = {
         "Assoc London": "http://heuristscholar.org/relmap/img/AssocLondon.gif",
         "Assoc other": "http://heuristscholar.org/relmap/img/AssocOther.gif",
         "Business London": "http://heuristscholar.org/relmap/img/BusinessLondon.gif",
         "Business other": "http://heuristscholar.org/relmap/img/BusinessOther.gif",
         "FE London": "http://heuristscholar.org/relmap/img/FELondon.gif",
         "FE other": "http://heuristscholar.org/relmap/img/FEOther.gif",
         "HE other": "http://heuristscholar.org/relmap/img/HEother.gif",
         "London Higher": "http://heuristscholar.org/relmap/img/HELondon.gif",
         "London Higher Parent": "http://heuristscholar.org/relmap/img/HELondon.gif",
         "Res London": "http://heuristscholar.org/relmap/img/ResLondon.gif",
         "Res other": "http://heuristscholar.org/relmap/img/ResOther.gif",
         "default": "http://heuristscholar.org/relmap/img/ResOther.gif"
};


app.getOrgTypeIconPath = function(orgType, forIcon) {
        if (forIcon) {
            return app.iconsByOrgType[orgType] ? app.iconsByOrgType[orgType] : app.iconsByOrgType["default"];
        }
        return app.gifsByOrgType[orgType] ? app.gifsByOrgType[orgType]:app.gifsByOrgType["default"];
}

function moveEndCallback() {
	document.getElementById("loading-div").style.display = "none";
}



</script>
</head>
<body class=mainpage onload="app.load();"  style="margin-bottom: 0; margin-top:0">

<div id=container>
 <div id=banner></div>
 <div id=center style="height:750px;" style="padding-right:0px">
  <div id=mapcontainer >
   <div id=loading-div style="position: absolute; width: 500px; z-index: 100000;"><img src="/relmap/loading-animation.gif" style="position: absolute; right: 10px; top: 10px;"></div>
   <div id=map style="width: 500px; height: 700px;"></div>
   <div id="my-timeline" style="width: 500px; height: 20px;"></div>
   <div id=info style="height: 30px; padding-top:10px;">
    <label for=filter><input style="display:none;" type=checkbox id=filter onclick="timeChange()"> Drag blue bar ends to change time filtering</label>
	&nbsp; &nbsp; <span id="loadingmessage"> </span>
   </div>
   <div id=cache-map style="position: absolute; visibility: hidden; top: -1000px; width: 500px; height: 640px;"></div>



  </div>

 </div>

 <div id=right style="height:750px;" style="padding-right:0px">

  <div>
    <h2>
     <a href="#" onclick="gotoPreviousRecord(); return false;" style="float: left; padding: 0 1ex;">back</a>
     <a href="#" onclick="gotoNextRecord(); return false;" style="float: left; padding: 0 1ex;">forward</a>
     Resources
    </h2>
   </div>


   <div style="padding-bottom:18px;" >
          &nbsp;
          <input type="text" id="search-string" style="width:150px;">
          <input type="button" value="search" onclick="doSearch();" >
          <input type="button" id="clear-search" value="clear" onclick="clearSearchResult();" style="display:none" >

   </div>



  <div style="vertical-align: top; height:600px;" id="contentcell">

    <!-- added by nan -->
   <div id="searchresults"  class="content" style="overflow:auto; display:none; height:660;">
   </div>
   <!-- added by nan -->
<div id=contentframe style="height:660px">
    <table> <tbody>
         <tr>
             <td style="float:left;"><h3><a id=current-record-link title="View resource details" href="#"
                    onclick="window.open(this.href, '', 'status=1,scrollbars=1,width=600,height=500'); return false;"><img id=current-record-image style="display: none;"></a>
                 &nbsp;</h3>
             </td>
             <td style="float:left;">
              <h3 id=current-record-title></h3>
             </td>
         </tr>
    </tbody></table>
  <div  style="overflow: auto; height:620px">
   <div class=content>
    <div id=other-records></div>
   </div>
  </div>
</div>
  </div>


 </div>

</div>

</body>
</html>
